<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          【深入理解Java虚拟机】【07】虚拟机类加载机制 - Charlie | Blog
        
    </title>

    <link rel="canonical" href="http://charliewong001.github.io/article/jvm/understanding-the-jvm/【07】虚拟机类加载机制/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS --> 
    <link rel="stylesheet" href="/css/beantech.min.css">

    <link rel="stylesheet" href="/css/donate.css">
    
    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <link rel="stylesheet" href="/css/widget.css">

    <link rel="stylesheet" href="/css/rocket.css">

    <link rel="stylesheet" href="/css/signature.css">

    <link rel="stylesheet" href="/css/toc.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('/img/header_img/article.jpg')
            /*post*/
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#JVM" title="JVM">JVM</a>
                            
                        </div>
                        <h1>【深入理解Java虚拟机】【07】虚拟机类加载机制</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by Charlie on
                            2019-08-30
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Charlie</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<!--
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <p>[TOC]</p>
<h2 id="概述">概述</h2>
<p>在Class文件中描述的各种信息，最终都需要加载到虚拟机中之后才能运行和使用。<br>
虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。<br>
与那些在编译时需要进行连接工作的语言不同，<font color="red">在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的</font>，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。例如，<font color="red">如果编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类；用户可以通过Java预定义的和自定义类加载器，让一个本地的应用程序可以在运行时从网络或其他地方加载一个二进制流作为程序代码的一部分，这种组装应用程序的方式目前已广泛应用于Java程序之中</font>。从最基础的Applet、JSP到相对复杂的OSGi技术，都使用了Java语言运行期类加载的特性。</p>
<h2 id="类加载的时机">类加载的时机</h2>
<p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：</p>
<ol>
<li>加载（Loading）</li>
<li>连接（Linking）：
<ul>
<li>验证（Verification）</li>
<li>准备（Preparation）</li>
<li>解析（Resolution）</li>
</ul>
</li>
<li>初始化（Initialization）</li>
<li>使用（Using）</li>
<li>卸载（Unloading）</li>
</ol>
<h3 id="主动引用">主动引用</h3>
<p>虚拟机规范严格要求<strong>有且仅有5种情况</strong>必须立即对类进行“初始化”，即开始加载</p>
<ol>
<li>遇到new，getstatic，putstatic或invokestatic这四条字节码指令的时候，且类没有被初始化过
<ul>
<li>使用new实例化对象的时候</li>
<li>读取或者设置一个类的静态字段（被final修饰，已在编译期把结果放到常量池的静态字段除外）</li>
<li>调用一个类的静态方法的时候。</li>
</ul>
</li>
<li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果这个类没有进行过初始化</li>
<li>当初始化一个类，发现其父类还没有进行初始化，需要先触发父类的初始化</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类）</li>
<li>当使用JDK 1.7的动态语言支持，如果一个java.lang.invoke.MethodHandle实例最后解析结果是REF_getStatic，REF_putStatic，REF_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行过初始化。</li>
</ol>
<h3 id="被动引用">被动引用</h3>
<p>除主动引用的情况外，其他所有情况都属于被动引用</p>
<ul>
<li>
<p>通过其子类来引用父类中定义的静 态字段，只会触发父类的初始化而不会触发子类的初始化。</p>
</li>
<li>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.fenixsoft.classloading；</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*被动使用类字段演示一：</span></span><br><span class="line"><span class="comment">*通过子类引用父类的静态字段，不会导致子类初始化</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span>&#123;</span><br><span class="line">  	System.out.println（<span class="string">"SuperClass init！"</span>）；</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value=<span class="number">123</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span>&#123;</span><br><span class="line">  	System.out.println（<span class="string">"SubClass init！"</span>）；</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*非主动使用类字段演示</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（String[]args）&#123;</span><br><span class="line">  	System.out.println（SubClass.value）；</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>创建数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.fenixsoft.classloading；</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*被动使用类字段演示二：</span></span><br><span class="line"><span class="comment">*通过数组定义来引用类，不会触发此类的初始化</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（String[]args）&#123;</span><br><span class="line">  	SuperClass[]sca=<span class="keyword">new</span> SuperClass[<span class="number">10</span>]；</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码里面触发了另外一个名为“[Lorg.fenixsoft.classloading.SuperClass”的类的初始化 阶段，对于用户代码来说，这并不是一个合法的类名称，它是一个由虚拟机自动生成的、直 接继承于java.lang.Object的子类，创建动作由字节码指令newarray触发。</p>
<p>这个类代表了一个元素类型为org.fenixsoft.classloading.SuperClass的一维数组，数组中应 有的属性和方法（用户可直接使用的只有被修饰为public的length属性和clone（）方法）都实 现在这个类里。Java语言中对数组的访问比C/C++相对安全是因为这个类封装了数组元素的 访问方法[1]，而C/C++直接翻译为对数组指针的移动。在Java语言中，当检查到发生数组越界 时会抛出java.lang.ArrayIndexOutOfBoundsException异常。</p>
</blockquote>
</li>
<li>
<p>常量传播优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.fenixsoft.classloading；</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*被动使用类字段演示三：</span></span><br><span class="line"><span class="comment">*常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span>&#123;</span><br><span class="line">  	System.out.println（<span class="string">"ConstClass init！"</span>）；</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD=<span class="string">"hello world"</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*非主动使用类字段演示</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（String[]args）&#123;</span><br><span class="line">  	System.out.println（ConstClass.HELLOWORLD）；</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述代码运行之后，也没有输出“ConstClass init！”，这是因为虽然在Java源码中引用了 ConstClass类中的常量HELLOWORLD，但其实在编译阶段通过常量传播优化，已经将此常量 的值“hello world”存储到了NotInitialization类的常量池中，以后NotInitialization对常量 ConstClass.HELLOWORLD的引用实际都被转化为NotInitialization类对自身常量池的引用了。 也就是说，实际上NotInitialization的Class文件之中并没有ConstClass类的符号引用入口，这两 个类在编译成Class之后就不存在任何联系了。</p>
</blockquote>
</li>
</ul>
<h3 id="接口与类的加载过程差异">接口与类的加载过程差异</h3>
<p>接口的加载过程与类加载过程稍有一些不同，针对接口需要做一些特殊说明：接口也有 初始化过程，这点与类是一致的，上面的代码都是用静态语句块“static{}”来输出初始化信息 的，而接口中不能使用“static{}”语句块，但编译器仍然会为接口生成“＜clinit＞（）”类构造 器，用于初始化接口中所定义的成员变量。接口与类真正有所区别的是前面讲述的5种“有 且仅有”需要开始初始化场景中的第3种：当一个类在初始化时，要求其父类全部都已经初始 化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使 用到父接口的时候（如引用接口中定义的常量）才会初始化。</p>
<h2 id="类加载过程">类加载过程</h2>
<h3 id="加载">加载</h3>
<p>加载是类加载过程的一个阶段，在加载过程虚拟机需要完成3件事情：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将一个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li><font color="red">在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</font></li>
</ol>
<p><strong>数组类型的加载过程</strong></p>
<p>一个数组类创建过程遵循以下规则：</p>
<ul>
<li>
<p>如果数据的组件类型是引用类型，那就递归的加载这个组件类型，<font color="red">数组C将在加载该组件类型 的类加载器的类名称空间上被标识（这点很重要，在7.4节会介绍到，一个类必须与类加载 器一起确定唯一性）</font></p>
<blockquote>
<p>组件类型：指的是数组去掉一个维度的类型</p>
</blockquote>
</li>
<li>
<p>如果数组的组件类型不是引用类型（例如int[]数组），Java虚拟机将会把数组C标记为与引导类加载器关联</p>
</li>
<li>
<p>数据类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public</p>
</li>
</ul>
<p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构。<font color="red">然后在内存中实例化一个java.lang.Class类的对象（并没有明确规定是在Java堆中，对于HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区里面），这个对象将作为程序访问方法区中的这些类型数据的外部接口。</font></p>
<blockquote>
<p>java8之后，取消了方法区，改为元数据区</p>
</blockquote>
<h3 id="验证">验证</h3>
<ol>
<li>
<p>文件格式验证</p>
<blockquote>
<p>a.是否以魔数0xCAFEBABE开头</p>
<p>b.主、次版本号是否在当前虚拟机处理范围之内。</p>
<p>c.常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。</p>
<p>d.指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</p>
<p>e.CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据。</p>
<p>f.Class文件中各个部分及文件本身是否有被删除的或附加的其他信息</p>
<p>…</p>
</blockquote>
</li>
<li>
<p>元数据验证</p>
<blockquote>
<p>a.这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。</p>
<p>b.这个类的父类是否继承了不允许被继承的类（被final修饰的类）。</p>
<p>c.如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</p>
<p>d.类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合 规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。</p>
<p>…</p>
</blockquote>
</li>
<li>
<p>字节码验证</p>
<blockquote>
<p>第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析， 确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型做完校验后， 这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机 安全的事件。</p>
</blockquote>
</li>
<li>
<p>符号引用验证</p>
<p>符号引用验证的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将 在连接的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中 的各种符号引用）的信息进行匹配性校验，通常需要校验下列内容：</p>
<blockquote>
<p>a.通过字符串描述的全限定名是否能找到对应的类</p>
<p>b.在指定类中是否存在符合方法的字段的描述符以及简单名称所描述的方法和字段</p>
<p>c.符号引用的类，字段，方法的访问性是否可被当前类访问</p>
<p>注：如果无法通过符号引用验证，那么将会抛出一个java.lang.IncompatibleClassChangeError异常的子类：java.lang.IllegalAccessError, java.lang.NoSuchFieldError, java.lang.NoSuchMethodError等。</p>
<p>通过-Xverify:none参数可以关闭大部分类验证措施</p>
</blockquote>
</li>
</ol>
<h3 id="准备">准备</h3>
<p><strong><em>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存 都将在方法区中进行分配。</em></strong></p>
<p>这个阶段中有两个容易产生混淆的概念需要强调一下，首先，这 时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将 会在对象实例化时随着对象一起分配在Java堆中。其次，这里所说的初始值“通常情况”下是 数据类型的零值。假设一个类变量的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>；</span><br></pre></td></tr></table></figure>
<p>那变量value在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java 方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器＜clinit＞（）方 法之中，所以把value赋值为123的动作将在初始化阶段才会执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>；</span><br></pre></td></tr></table></figure>
<p>注：如果被final修饰，字段属性表会存在ConstantValue属性，那么准备阶段变量value就会被初始化成123.</p>
<p>注：所有基本数据类型的零值</p>
<table>
<thead>
<tr>
<th style="text-align:left">数据类型</th>
<th style="text-align:left">零值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">int</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">long</td>
<td style="text-align:left">0L</td>
</tr>
<tr>
<td style="text-align:left">short</td>
<td style="text-align:left">(short)0</td>
</tr>
<tr>
<td style="text-align:left">char</td>
<td style="text-align:left">‘\u0000’</td>
</tr>
<tr>
<td style="text-align:left">byte</td>
<td style="text-align:left">(byte)0</td>
</tr>
<tr>
<td style="text-align:left">boolean</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left">float</td>
<td style="text-align:left">0.0f</td>
</tr>
<tr>
<td style="text-align:left">double</td>
<td style="text-align:left">0.0d</td>
</tr>
<tr>
<td style="text-align:left">refrence</td>
<td style="text-align:left">null</td>
</tr>
</tbody>
</table>
<h3 id="解析">解析</h3>
<p><strong><em>解析阶段是虚拟机将常量池中的符号引用替换为直接引用的过程</em></strong></p>
<p>在Class文件格式中它以CONSTANT_Class_info, CONSTANT_Fiedref_info, CONTSTANT_Methodref_info等类型的常量出现，那解析阶段中所说的直接引用与符号引用又有什么关联呢？</p>
<p><font color="red">什么是符号引用，直接引用？</font></p>
<blockquote>
<p><strong>符号引用</strong></p>
<p>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。例如，在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现。符号引用与虚拟机的内存布局无关，引用的目标并不一定加载到内存中。在Java中，一个java类将会编译成一个class文件。在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language（实际中是由类似于CONSTANT_Class_info的常量来表示的）来表示Language类的地址。各种虚拟机实现的内存布局可能有所不同，但是它们能接受的符号引用都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。</p>
<p><strong>直接引用</strong></p>
<p>直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了。</p>
<p>直接引用可以有不同的实现方式：</p>
<ul>
<li>直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）</li>
<li>相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）</li>
<li>一个能间接定位到目标的句柄</li>
</ul>
</blockquote>
<p>虚拟机规范之中并未规定解析阶段发生的具体时间，只要求了在执行</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anewarray、 checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invokespecial、 invokestatic、invokevirtual、ldc、ldc_w、multianewarray、new、putfield、putstatic</span><br></pre></td></tr></table></figure>
<p>这16个用于 操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。</p>
<p>所以虚拟机实现可 以根据需要来判断到底是在</p>
<p>1.类被加载器加载时就对常量池中的符号引用进行解析</p>
<p>2.还是等到 一个符号引用将要被使用前才去解析它。</p>
<p>除 invokedynamic 指令以外，虚拟 机实现可以对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标识 为已解析状态）从而避免解析动作重复进行。</p>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点 限定符7类符号引用进行。</p>
<p>分别对应于常量池的</p>
<p>CONSTANT_Class_info</p>
<p>CONSTANT_Fieldref_info</p>
<p>CONSTANT_Methodref_info</p>
<p>CONSTANT_InterfaceMethodref_info</p>
<p>CONSTANT_MethodType_info</p>
<p>CONSTANT_MethodHandle_info</p>
<p>CONSTANT_InvokeDynamic_info</p>
<p>7种常量类型。</p>
<h4 id="类或接口的解析">类或接口的解析</h4>
<p>当前类为D，未解析符号引用为N，解析为一个类或者接口C的直接引用</p>
<ol>
<li>C非数组，把N的全限定名传给D的类加载器去加载C，可能触发其他相关 类的加载动作，例如加载这个类的父类或实现的接口。</li>
<li>C是数组，并且数据元素为对象，也就是N的描述符会是类 似“[Ljava/lang/Integer”的形式，那么按上面描述加载数据元素类型，就是“java.lang.Integer”，接着由虚拟机生成一个 代表此数组维度和元素的数组对象。</li>
<li>上面步骤没有异常，C就是一个有效的类或者接口了，解析完成前，需要验证，确认D是否有对C的访问权限。</li>
</ol>
<h4 id="字段解析">字段解析</h4>
<p>解析字段符号引用，首先对字段表内的class_index项索引的CONSTANT_Class_info符号引用进行解析，如果成功，将这个类或者接口用C表示</p>
<ol>
<li>如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>否则，如果C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父接口，如果父接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>否则查找结束，抛出java.lang.NoSuchFieldError异常。</li>
</ol>
<p>成功返回后，会对这个字段做权限验证，如果发现不具备对字段 的访问权限，将抛出java.lang.IllegalAccessError异常。</p>
<h4 id="类方法解析">类方法解析</h4>
<p>类方法解析的第一个步骤与字段解析一样，也需要先解析出类方法表的class_index 项中 索引的方法所属的类或接口的符号引用，如果解析成功，我们依然用C表示这个类，接下来 虚拟机将会按照如下步骤进行后续的类方法搜索。</p>
<ol>
<li>
<p>类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现 class_index中索引的C是个接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。</p>
<blockquote>
<p><font color="red">java8以后，在接口中也可以定义方法。</font></p>
</blockquote>
</li>
<li>
<p>如果通过了第1步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法， 如果有则返回这个方法的直接引用，查找结束。</p>
</li>
<li>
<p>否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如 果有则返回这个方法的直接引用，查找结束。</p>
</li>
<li>
<p>否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符 都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时查找结束，抛 出java.lang.AbstractMethodError异常。</p>
</li>
<li>
<p>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError。</p>
</li>
</ol>
<p>最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不 具备对此方法的访问权限，将抛出java.lang.IllegalAccessError异常。</p>
<h4 id="接口方法解析">接口方法解析</h4>
<p>接口方法也需要先解析出接口方法表的class_index 项中索引的方法所属的类或接口的符 号引用，如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下步骤进行后续 的接口方法搜索。</p>
<ol>
<li>与类方法解析不同，如果在接口方法表中发现class_index中的索引C是个类而不是接 口，那就直接抛出java.lang.IncompatibleClassChangeError异常。</li>
<li>否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返 回这个方法的直接引用，查找结束。</li>
<li>否则，在接口C的父接口中递归查找，直到java.lang.Object类（查找范围会包括 Object类）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方 法的直接引用，查找结束。</li>
<li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。</li>
</ol>
<p>由于接口中的所有方法默认都是public的，所以不存在访问权限的问题，因此接口方法 的符号解析应当不会抛出java.lang.IllegalAccessError异常。</p>
<h3 id="初始化">初始化</h3>
<ul>
<li><clinit>()方法是由编译器自动收集类中所有<strong>类变量</strong>的赋值动作和<strong>静态语句块</strong>（static块）中的语句合并而成，编译器收集的顺序是由语句在源文件中出现的顺序所决定的。
<ul>
<li>静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问</li>
</ul>
</clinit></li>
<li><clinit>()方法与类的构造函数<init>()不同，它不需要显式的调用父类的构造器，虚拟机会保证子类的<clinit>()方法之前，父类的<clinit>()方法执行完毕。因此虚拟机中第一个被执行的<clinit>()方法类肯定是java.lang.Object</clinit></clinit></clinit></init></clinit></li>
<li>由于父类的<clinit>()方法先执行，也就意味着父类的静态语句块会优先于子类赋值</clinit></li>
<li><clinit>()方法对于类或者接口不是必须的，没有静态语句块也没有赋值的话，编译器可以不为这个类生成<clinit>()方法</clinit></clinit></li>
<li>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法，但是接口和类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法。只有当父接口中定义的变量使用时，父接口才会被初始化。</clinit></clinit></clinit></li>
<li>虚拟机会保证一个类的<clinit>()方法方法在多线程环境中被正确的加锁，同步。如果一个类的<clinit>()方法方法中有耗时很长的操作，有可能造成多线程阻塞。</clinit></clinit></li>
</ul>
<p><strong><font color="red">&lt;clinit&gt;()方法和&lt;init&gt;()方法</font></strong></p>
<blockquote>
<ul>
<li>
<p>&lt;clinit&gt;()方法</p>
<p>由编译器自动收集类中所有<strong>类变量</strong>的赋值动作和<strong>静态语句块</strong>（static块）中的语句合并而成。</p>
</li>
<li>
<p>&lt;init&gt;()方法</p>
<p>对象构造时用以初始化对象的，构造器以及非静态初始化块中的代码。</p>
</li>
</ul>
</blockquote>
<p><strong><font color="red">什么是向前引用</font></strong></p>
<p>所谓向前引用，就是在定义类、接口、方法、变量之前使用它们</p>
<p><strong><font color="red">什么是非法向前引用</font></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		i = <span class="number">0</span>; <span class="comment">//给变量赋值可以正常通过</span></span><br><span class="line">		System.out.println(i); <span class="comment">//编译器提示非法向前引用</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> m = n;   <span class="comment">//非法向前引用</span></span><br><span class="line">    &#123;</span><br><span class="line">    	n = <span class="number">0</span>;</span><br><span class="line">    	System.out.println(n); <span class="comment">//非法向前引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面两个例子中都有非法向前引用的报错，即不能在变量声明之前引用这个变量，但是可以对此变量进行赋值。</p>
<p><strong><font color="red">为什么不允许向前引用？</font></strong></p>
<blockquote>
<p>这是java出于安全性考虑的：如果字段会进行初始化，一定要防止在初始化前程序中访问默认值（可以赋值但不可访问），这会导致很多意想不到的麻烦。</p>
<p>所以编译期会对变量还未完全初始化却在前面被引用的现象进行检查并规避。</p>
</blockquote>
<p>再看下面这个demo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">method</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> n; &#125;  </span><br><span class="line">    <span class="keyword">int</span> m = method();  </span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个demo，在变量n定义之前就对n进行了引用，只不过引用是在一个方法中，这时编译器不会报非法向前引用。</p>
<p>此时输出m和n，分别为0和1。</p>
<p>new MyClass()操作，jvm在堆中划分相应的空间，并为成员变量赋初值（零值），</p>
<p>然后执行成员变量初始化的操作，jvm会统一收集到<init>方法中，会按照成员变量出现的顺序生成相应初始化字节码指令。</init></p>
<p>所以首先会初始化m，调用method方法，返回n时，n还没有进行初始化，所以n是默认值0，返回将m初始化为0。</p>
<p>然后初始化n，将n初始化为1.</p>
<p><strong><font color="red">为什么上面的demo中可以向前引用？</font></strong></p>
<blockquote>
<p>这主要是因为，这里的向前引用是在方法中，编译器对此无能为力，因为在编译期它无法知道是什么样的值赋值给了m。所以编译器并不会报错，但是我们要避免这样的现象发生。</p>
</blockquote>
<h2 id="类加载器">类加载器</h2>
<p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字 节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的 类。实现这个动作的代码模块称为“类加载器”。 类加载器可以说是Java语言的一项创新，也是Java语言流行的重要原因之一，它最初是 为了满足Java Applet的需求而开发出来的。虽然目前Java Applet技术基本上已经“死掉” [1]，但 类加载器却在类层次划分、OSGi、热部署、代码加密等领域大放异彩，成为了Java技术体系 中一块重要的基石，可谓是失之桑榆，收之东隅。</p>
<h3 id="类与类加载器">类与类加载器</h3>
<p>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意 义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类 加载器不同，那这两个类就必定不相等。</p>
<h3 id="双亲委派模型">双亲委派模型</h3>
<p><img src="/postImg/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.png" alt="类加载器"></p>
<ul>
<li>
<p>启动类加载器</p>
<blockquote>
<p>这个类加载器使用C++语言实现[1]，是虚拟机自身的一部分。</p>
<p>这个类将器负责将存放在＜ JAVA_HOME＞\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机 识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载） 类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用</p>
</blockquote>
</li>
<li>
<p>扩展类加载器</p>
<blockquote>
<p>这个加载器由sun.misc.Launcher $ExtClassLoader实现，它负责加载＜JAVA_HOME＞\lib\ext目录中的，或者被java.ext.dirs系 统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</p>
</blockquote>
</li>
<li>
<p>应用程序类加载器</p>
<blockquote>
<p>这个类加载器由sun.misc.Launcher $AppClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader（）方法的返回 值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类 库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一 般情况下这个就是程序中默认的类加载器。</p>
</blockquote>
</li>
</ul>
<ol>
<li>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当 有自己的父类加载器。使用组合（Composition）关系来复用父加载器的代码</li>
<li>如果一个类加载器收到了类加载的请求，它首先不会自己 去尝试加载这个类，而是把这个请求委派给父类加载器去完成，只有当父类加载器反馈自己无法加载这个加载请求的时候，子加载器才会尝试自己去加载。</li>
</ol>
<h3 id="破坏双亲委派模型">破坏双亲委派模型</h3>
<h4 id="第一次破坏">第一次破坏</h4>
<p>JDK1.2之前并未引入双亲委派模型，所以为向前兼容，JDK1.2之前覆盖loadClass方法。</p>
<p>JDK 1.2之后已不提倡用户再去覆盖loadClass（）方法，而应当把自己的类加载逻辑 写到findClass（）方法中，在loadClass（）方法的逻辑里如果父类加载失败，则会调用自己 的findClass（）方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派规则 的。</p>
<h4 id="第二次破坏">第二次破坏</h4>
<p>双亲委派很好地解 决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），基础类 之所以称为“基础”，是因为它们总是作为被用户代码调用的API。</p>
<p><strong>如果基础类又要调用回用户的代码，那该怎么办？</strong></p>
<p>个典型的例子便是JNDI服务。</p>
<p>它的代码由启动类加载器去加载（在JDK 1.3时放进去的rt.jar），但JNDI的目的就是对 资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的ClassPath下的 JNDI接口提供者（SPI,Service Provider Interface）的代码，但启动类加载器不可能“认识”这些 代码啊！那该怎么办？</p>
<blockquote>
<p>如果类A中调用了类B，那么加载B的时候，需要使用A的类加载器去加载B。</p>
<p>如果A是基础类，B是用户类，那么A对应的最上层类加载器，是没办法处理下层的用户类的。</p>
</blockquote>
<p><strong><em>线程上下文类加载 器（Thread Context ClassLoader）</em></strong></p>
<blockquote>
<p>为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：线程上下文类加载 器（Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的 setContextClassLoaser（）方法进行设置，如果创建线程时还未设置，它将会从父线程中继承 一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序 类加载器。</p>
<p>有了线程上下文类加载器，就可以做一些“舞弊”的事情了。</p>
<p><font color="red">JNDI服务使用这个线程上下 文类加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动 作</font>，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，实际上已经 违背了双亲委派模型的一般性原则，但这也是无可奈何的事情。Java中所有涉及SPI的加载动 作基本上都采用这种方式，例如JNDI、JDBC、JCE、JAXB和JBI等。</p>
</blockquote>
<h4 id="第三次破坏">第三次破坏</h4>
<p>第三次“被破坏”是由于用户对程序动态性的追求而导致的。</p>
<p>如：代码热替换（HotSwap）、模块热部署（Hot Deployment）等。</p>
<p><strong><em>在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加 复杂的网状结构</em></strong></p>
<p><strong><em>当收到类加载请求时，OSGi将按照下面的顺序进行类搜索</em></strong></p>
<ol>
<li>将以java.*开头的类委派给父类加载器加载。</li>
<li>否则，将委派列表名单内的类委派给父类加载器加载。</li>
<li>否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载。</li>
<li>否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。</li>
<li>否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的 类加载器加载。</li>
<li>否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。</li>
<li>否则，类查找失败。</li>
</ol>
<p>上面的查找顺序中只有开头两点仍然符合双亲委派规则，其余的类查找都是在平级的类 加载器中进行的。</p>

                

                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/article/jvm/understanding-the-jvm/【08】虚拟机字节码执行引擎/" data-toggle="tooltip" data-placement="top" title="【深入理解Java虚拟机】【08】虚拟机字节码执行引擎">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/article/jvm/understanding-the-jvm/【06】类文件结构/" data-toggle="tooltip" data-placement="top" title="【深入理解Java虚拟机】【06】类文件结构">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                <br>

                <!--打赏-->
                
                <!--打赏-->

                <br>
                <!--分享-->
                
                    <div class="social-share"  data-wechat-qrcode-helper="" align="center"></div>
                    <!--  css & js -->
                    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
                    <script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>
                
                <!--分享-->
                <br>                       
                
                <!-- require APlayer -->
                

                <!-- duoshuo Share start -->
                
                <!-- 多说 Share end-->

                <!-- 多说评论框 start -->
                
                <!-- 多说评论框 end -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->

                

            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

  
    <style>
      span.toc-nav-number{
        display: none
      }
    </style>
  
    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#概述"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">&#x6982;&#x8FF0;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#类加载的时机"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">&#x7C7B;&#x52A0;&#x8F7D;&#x7684;&#x65F6;&#x673A;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#主动引用"><span class="toc-nav-number">2.1.</span> <span class="toc-nav-text">&#x4E3B;&#x52A8;&#x5F15;&#x7528;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#被动引用"><span class="toc-nav-number">2.2.</span> <span class="toc-nav-text">&#x88AB;&#x52A8;&#x5F15;&#x7528;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#接口与类的加载过程差异"><span class="toc-nav-number">2.3.</span> <span class="toc-nav-text">&#x63A5;&#x53E3;&#x4E0E;&#x7C7B;&#x7684;&#x52A0;&#x8F7D;&#x8FC7;&#x7A0B;&#x5DEE;&#x5F02;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#类加载过程"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">&#x7C7B;&#x52A0;&#x8F7D;&#x8FC7;&#x7A0B;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#加载"><span class="toc-nav-number">3.1.</span> <span class="toc-nav-text">&#x52A0;&#x8F7D;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#验证"><span class="toc-nav-number">3.2.</span> <span class="toc-nav-text">&#x9A8C;&#x8BC1;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#准备"><span class="toc-nav-number">3.3.</span> <span class="toc-nav-text">&#x51C6;&#x5907;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#解析"><span class="toc-nav-number">3.4.</span> <span class="toc-nav-text">&#x89E3;&#x6790;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#类或接口的解析"><span class="toc-nav-number">3.4.1.</span> <span class="toc-nav-text">&#x7C7B;&#x6216;&#x63A5;&#x53E3;&#x7684;&#x89E3;&#x6790;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#字段解析"><span class="toc-nav-number">3.4.2.</span> <span class="toc-nav-text">&#x5B57;&#x6BB5;&#x89E3;&#x6790;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#类方法解析"><span class="toc-nav-number">3.4.3.</span> <span class="toc-nav-text">&#x7C7B;&#x65B9;&#x6CD5;&#x89E3;&#x6790;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#接口方法解析"><span class="toc-nav-number">3.4.4.</span> <span class="toc-nav-text">&#x63A5;&#x53E3;&#x65B9;&#x6CD5;&#x89E3;&#x6790;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#初始化"><span class="toc-nav-number">3.5.</span> <span class="toc-nav-text">&#x521D;&#x59CB;&#x5316;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#类加载器"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">&#x7C7B;&#x52A0;&#x8F7D;&#x5668;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#类与类加载器"><span class="toc-nav-number">4.1.</span> <span class="toc-nav-text">&#x7C7B;&#x4E0E;&#x7C7B;&#x52A0;&#x8F7D;&#x5668;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#双亲委派模型"><span class="toc-nav-number">4.2.</span> <span class="toc-nav-text">&#x53CC;&#x4EB2;&#x59D4;&#x6D3E;&#x6A21;&#x578B;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#破坏双亲委派模型"><span class="toc-nav-number">4.3.</span> <span class="toc-nav-text">&#x7834;&#x574F;&#x53CC;&#x4EB2;&#x59D4;&#x6D3E;&#x6A21;&#x578B;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#第一次破坏"><span class="toc-nav-number">4.3.1.</span> <span class="toc-nav-text">&#x7B2C;&#x4E00;&#x6B21;&#x7834;&#x574F;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#第二次破坏"><span class="toc-nav-number">4.3.2.</span> <span class="toc-nav-text">&#x7B2C;&#x4E8C;&#x6B21;&#x7834;&#x574F;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#第三次破坏"><span class="toc-nav-number">4.3.3.</span> <span class="toc-nav-text">&#x7B2C;&#x4E09;&#x6B21;&#x7834;&#x574F;</span></a></li></ol></li></ol></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#JVM" title="JVM">JVM</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
            </div>
        </div>
    </div>
</article>








<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/charliewong001">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Charlie 2019 
                    <br>
                    <!--
                    Theme by <a href="http://beantech.org">BeanTech</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    re-Ported by <a href="http://www.huweihuang.com">胡伟煌</a> | 
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=huweihuang&repo=hexo-theme-huweihuang&type=star&count=true" >
                    </iframe>
                    -->
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://charliewong001.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-XXXXXXXX-X';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = 'xxx';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="http://charliewong001.github.io/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
